#include "sockets.h"

int crearSocket() {

	int newSocket;
	int si = 1;
	if ((newSocket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
		return EXIT_FAILURE;
	} else {
		if (setsockopt(newSocket, SOL_SOCKET, SO_REUSEADDR, &si, sizeof(int))
				== -1) {
			return EXIT_FAILURE;
		}
		return newSocket;
	}
}

int bindearSocket(int newSocket, tSocketInfo socketInfo) {
	if (bind(newSocket, (struct sockaddr*) &socketInfo, sizeof(socketInfo))
			== -1) {
		perror("Error al bindear socket escucha");
		return EXIT_FAILURE;
	} else {
		return EXIT_SUCCESS;
	}
}

int escucharEn(int newSocket) {
	if (listen(newSocket, BACKLOG) == -1) {
		perror("Error al poner a escuchar socket");
		return EXIT_FAILURE;
	} else {
		return EXIT_SUCCESS;
	}
}

int conectarAServidor(char *ipDestino, unsigned short puertoDestino) {
	int socketDestino;
	tSocketInfo infoSocketDestino;
	infoSocketDestino.sin_family = AF_INET;
	infoSocketDestino.sin_port = htons(puertoDestino);
	inet_aton(ipDestino, &infoSocketDestino.sin_addr);
	memset(&(infoSocketDestino.sin_zero), '\0', 8);

	if ((socketDestino = crearSocket()) == EXIT_FAILURE) {
		perror("Error al crear socket");
		return -1;
	}

	if (connect(socketDestino, (struct sockaddr*) &infoSocketDestino,
			sizeof(infoSocketDestino)) == -1) {
		perror("Error al conectar socket");
		close(socketDestino);
		return -1;
	}

	return socketDestino;
}

int desconectarseDe(int socket) {
	if (close(socket)) {
		return EXIT_SUCCESS;
	} else {
		return EXIT_FAILURE;
	}
}

int32_t enviarMensaje(int32_t numSocket, t_header header, t_contenido mensaje,
		t_log *logger) {

	puts("llego aca?");
	if (strlen(mensaje) > sizeof(t_contenido)) {
		log_error(logger,
				"Error en el largo del mensaje, tiene que ser menor o igual al máximo: %s",
				MSG_SIZE);
		return -1;
	}

	t_mensajes *s = malloc(sizeof(t_mensajes));
	s->id = header;
	strcpy(s->contenido, mensaje);
	log_info(logger, "Se ENVIA por SOCKET:%d - HEAD:%s MENSAJE:\"%s\" ",
			numSocket, getDescription(s->id), s->contenido);
	int n = send(numSocket, s, sizeof(*s), 0);
	if (n != STRUCT_SIZE) {
		log_error(logger,
				"#######################################################################");
		log_error(logger,
				"##    ERROR en el envío de mensajes: no se envió todo. socket: %d    ##",
				numSocket);
		log_error(logger,
				"#######################################################################");
	}
	free(s);
	return n;
}

t_header recibirMensaje(int numSocket, t_contenido mensaje, t_log *logger) {

	char buffer[STRUCT_SIZE];

	log_debug(logger, "Estoy en recv");
	int n = recv(numSocket, buffer, STRUCT_SIZE, 0);

	if (n == STRUCT_SIZE) {
		t_mensajes* s = (t_mensajes*) buffer;
		strcpy(mensaje, s->contenido);
		log_debug(logger,
				"Se RECIBE por SOCKET:%d - HEAD:%s%s%s MENSAJE:\"%s%s%s\" ",
				numSocket, getDescription(s->id), mensaje);
		return s->id;
	} else {
		if (n == 0) { // Conexión remota cerrada
			log_info(logger, "El socket %d cerró la conexion.", numSocket);
			strcpy(mensaje, "");
			return ERR_CONEXION_CERRADA;
		} else { // El mensaje tiene un tamaño distinto al esperado
			log_error(logger,
					"#######################################################");
			log_error(logger,
					"##    ERROR en el recibo de mensaje del socket %d    ##",
					numSocket);
			log_error(logger,
					"#######################################################");
			strcpy(mensaje, "");
			//usleep(500000);
			return ERR_ERROR_AL_RECIBIR_MSG;
		}
	}
}

int cerrarSocket(int numSocket, fd_set *fd) {

	close(numSocket);

	if (fd != NULL ) {
		FD_CLR(numSocket, fd);
	}
	return EXIT_SUCCESS;
}

void freeMensaje(t_mensaje* mensaje){
	free(mensaje->contenido);
	free(mensaje);
}

char* getDescription(int item) {

	switch (item) {
	case ERR_CONEXION_CERRADA:
		return "ERR_CONEXION_CERRADA";
	case ERR_ERROR_AL_RECIBIR_MSG:
		return "ERR_ERROR_AL_RECIBIR_MSG";
	case ERR_ERROR_AL_ENVIAR_MSG:
		return "ERR_ERROR_AL_ENVIAR_MSG";

	case JOB_TO_NODO_MAP_REQUEST:
		return "JOB_TO_NODO_MAP_REQUEST";
	case JOB_TO_NODO_REDUCE_REQUEST:
		return "JOB_TO_NODO_REDUCE_REQUEST";

	case MARTA_TO_JOB_MAP_REQUEST:
		return "MARTA_TO_JOB_MAP_REQUEST";
	case MARTA_TO_JOB_REDUCE_REQUEST:
		return "MARTA_TO_JOB_REDUCE_REQUEST";
	case MARTA_TO_JOB:
		return "MARTA_TO_JOB";

	case NODO_TO_FS_HANDSHAKE:
		return "NODO_TO_FS_HANDSHAKE";
	case NODO_TO_FS_GET_BLOQUE_OK:
			return "NODO_TO_FS_GET_BLOQUE_OK";
	case NODO_TO_JOB_MAP_OK:
		return "NODO_TO_JOB_MAP_OK";
	case NODO_TO_JOB_MAP_KO:
		return "NODO_TO_JOB_MAP_KO";
	case NODO_TO_JOB_REDUCE_OK:
		return "NODO_TO_JOB_REDUCE_OK";
	case NODO_TO_JOB_REDUCE_KO:
		return "NODO_TO_JOB_REDUCE_KO";
	case NODO_TO_NODO_GET_BLOQUE:
		return "NODO_TO_NODO_GET_BLOQUE";
	case NODO_TO_NODO_SET_BLOQUE:
		return "NODO_TO_NODO_SET_BLOQUE";
	case NODO_TO_NODO_GET_FILE_CONTENT:
		return "NODO_TO_NODO_GET_FILE_CONTENT";
	case FS_TO_NODO_HANDSHAKE_OK:
		return "FS_TO_NODO_HANDSHAKE_OK";
	case FS_TO_NODO_GET_BLOQUE:
		return "FS_TO_NODO_GET_BLOQUE";
	case FS_TO_NODO_SET_BLOQUE:
		return "FS_TO_NODO_SET_BLOQUE";
	case FS_TO_NODO_GET_FILE_CONTENT:
		return "FS_TO_NODO_GET_FILE_CONTENT";
	case FIN:
		return "FIN";
	default:
		return "---DEFAULT--- (mensaje sin definir)";
	}
	return "";

}

#define PORT "9034"

int escuchar(int puertoEscucha, int socketServer, void (*funcionParaProcesarMensaje)(int, header_t*, void*, t_log*), void* extra,  t_log* logger) {





	fd_set masterFDList;    // master file descriptor list
	fd_set readFDList;  // temp file descriptor list for select()
	int maxFDNumber;        // maximum file descriptor number

	int socketEscucha;     // listening socket descriptor
	int nuevoFD;        // newly accept()ed socket descriptor
	struct sockaddr_storage remoteaddr; // client address
	socklen_t addrlen;

	char buf[256];    // buffer for client data
	int nbytes;

	char remoteIP[INET6_ADDRSTRLEN];

	int yes=1;        // for setsockopt() SO_REUSEADDR, below
	int socketActual, j, rv;

	struct addrinfo hints, *ai, *p;

	FD_ZERO(&masterFDList);    // clear the master and temp sets
	FD_ZERO(&readFDList);

	// get us a socket and bind it
	memset(&hints, 0, sizeof hints);
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_PASSIVE;
	if ((rv = getaddrinfo(NULL, PORT, &hints, &ai)) != 0) {
		fprintf(stderr, "selectserver: %s\n", gai_strerror(rv));
		exit(1);
	}

	for(p = ai; p != NULL; p = p->ai_next) {
		socketEscucha = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
		if (socketEscucha < 0) {
			continue;
		}

		// lose the pesky "address already in use" error message
		setsockopt(socketEscucha, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));

		if (bind(socketEscucha, p->ai_addr, p->ai_addrlen) < 0) {
			close(socketEscucha);
			continue;
		}

		break;
	}

	// if we got here, it means we didn't get bound
	if (p == NULL) {
		fprintf(stderr, "selectserver: failed to bind\n");
		exit(2);
	}

	freeaddrinfo(ai); // all done with this

	// listen
	if (listen(socketEscucha, 10) == -1) {
		perror("listen");
		exit(3);
	}

	// add the listener to the master set
	FD_SET(socketEscucha, &masterFDList);

	// keep track of the biggest file descriptor
	maxFDNumber = socketEscucha; // so far, it's this one

	// main loop
	for(;;) {
		readFDList = masterFDList; // copy it
		if (select(maxFDNumber+1, &readFDList, NULL, NULL, NULL) == -1) {
			perror("select");
			exit(4);
		}

		// run through the existing connections looking for data to read
		for(socketActual = 0; socketActual <= maxFDNumber; socketActual++) {
			if (FD_ISSET(socketActual, &readFDList)) { // we got one!!
				if (socketActual == socketEscucha) {
					// handle new connections
					addrlen = sizeof remoteaddr;
					nuevoFD = accept(socketEscucha,
						(struct sockaddr *)&remoteaddr,
						&addrlen);

					if (nuevoFD == -1) {
						perror("accept");
					} else {
						FD_SET(nuevoFD, &masterFDList); // add to master set
						if (nuevoFD > maxFDNumber) {    // keep track of the max
							maxFDNumber = nuevoFD;
						}
						printf("selectserver: new connection from %s on "
							"socket %d\n",
							inet_ntop(remoteaddr.ss_family,
								get_in_addr((struct sockaddr*)&remoteaddr),
								remoteIP, INET6_ADDRSTRLEN),
							nuevoFD);
					}
				} else {
					// handle data from a client
					if ((nbytes = recv(socketActual, buf, sizeof buf, 0)) <= 0) {
						// got error or connection closed by client
						if (nbytes == 0) {
							// connection closed
							printf("selectserver: socket %d hung up\n", socketActual);
						} else {
							perror("recv");
						}
						close(socketActual); // bye!
						FD_CLR(socketActual, &masterFDList); // remove from master set
					} else {
						// we got some data from a client
						for(j = 0; j <= maxFDNumber; j++) {
							// send to everyone!
							if (FD_ISSET(j, &masterFDList)) {
								// except the listener and ourselves
								if (j != socketEscucha && j != socketActual) {
									if (send(j, buf, nbytes, 0) == -1) {
										perror("send");
									}
								}
							}
						}
					}
				} // END handle data from client
			} // END got new incoming connection
		} // END looping through file descriptors
	} // END for(;;)--and you thought it would never end!

	return 0;
}


void *get_in_addr(struct sockaddr *sa) {
	if (sa->sa_family == AF_INET) {
		return &(((struct sockaddr_in*) sa)->sin_addr);
	}

	return &(((struct sockaddr_in6*) sa)->sin6_addr);
}

